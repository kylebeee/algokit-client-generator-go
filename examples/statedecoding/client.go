// Code generated by algokit-client-generator-go. DO NOT EDIT.
package statedecoding

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the StateDecoding smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendInit calls the init ABI method and waits for confirmation.
func (c *Client) SendInit(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "init",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendGetBox calls the getBox ABI method and waits for confirmation.
func (c *Client) SendGetBox(ctx context.Context, params algokit.CallParams[GetBoxArgs]) (*GetBoxMethodResult, error) {
	methodArgs := argsToInterfaceGetBox(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getBox",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetBoxMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([]byte); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendDoNothing calls the doNothing ABI method and waits for confirmation.
func (c *Client) SendDoNothing(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "doNothing",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendRawState calls the rawState ABI method and waits for confirmation.
func (c *Client) SendRawState(ctx context.Context, params algokit.CallParams[RawStateArgs]) (*RawStateMethodResult, error) {
	methodArgs := argsToInterfaceRawState(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "rawState",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &RawStateMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([]byte); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendDecodeAppList calls the decodeAppList ABI method and waits for confirmation.
func (c *Client) SendDecodeAppList(ctx context.Context, params algokit.CallParams[DecodeAppListArgs]) (*DecodeAppListMethodResult, error) {
	methodArgs := argsToInterfaceDecodeAppList(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "decodeAppList",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &DecodeAppListMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendDecodeUint64 calls the decodeUint64 ABI method and waits for confirmation.
func (c *Client) SendDecodeUint64(ctx context.Context, params algokit.CallParams[DecodeUint64Args]) (*DecodeUint64MethodResult, error) {
	methodArgs := argsToInterfaceDecodeUint64(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "decodeUint64",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &DecodeUint64MethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendDecodeStaticArray calls the decodeStaticArray ABI method and waits for confirmation.
func (c *Client) SendDecodeStaticArray(ctx context.Context, params algokit.CallParams[DecodeStaticArrayArgs]) (*DecodeStaticArrayMethodResult, error) {
	methodArgs := argsToInterfaceDecodeStaticArray(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "decodeStaticArray",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &DecodeStaticArrayMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendCheckObjectAssignment calls the checkObjectAssignment ABI method and waits for confirmation.
func (c *Client) SendCheckObjectAssignment(ctx context.Context, params algokit.CallParams[CheckObjectAssignmentArgs]) (*CheckObjectAssignmentMethodResult, error) {
	methodArgs := argsToInterfaceCheckObjectAssignment(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "checkObjectAssignment",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &CheckObjectAssignmentMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendRetObject calls the retObject ABI method and waits for confirmation.
func (c *Client) SendRetObject(ctx context.Context) (*RetObjectMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "retObject",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &RetObjectMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendRetDecode calls the retDecode ABI method and waits for confirmation.
func (c *Client) SendRetDecode(ctx context.Context) (*RetDecodeMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "retDecode",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &RetDecodeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendRetList calls the retList ABI method and waits for confirmation.
func (c *Client) SendRetList(ctx context.Context) (*RetListMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "retList",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &RetListMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([][]interface{}); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendPercentileCheck calls the percentileCheck ABI method and waits for confirmation.
func (c *Client) SendPercentileCheck(ctx context.Context) (*PercentileCheckMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "percentileCheck",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &PercentileCheckMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([5]uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendBigLoop calls the bigLoop ABI method and waits for confirmation.
func (c *Client) SendBigLoop(ctx context.Context) (*BigLoopMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "bigLoop",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &BigLoopMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendBigCLoop calls the bigCLoop ABI method and waits for confirmation.
func (c *Client) SendBigCLoop(ctx context.Context) (*BigCLoopMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "bigCLoop",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &BigCLoopMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([]interface{}); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendNullun calls the nullun ABI method and waits for confirmation.
func (c *Client) SendNullun(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "nullun",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendDynamicArrayOfDynamicArrays calls the dynamicArrayOfDynamicArrays ABI method and waits for confirmation.
func (c *Client) SendDynamicArrayOfDynamicArrays(ctx context.Context, params algokit.CallParams[DynamicArrayOfDynamicArraysArgs]) (*DynamicArrayOfDynamicArraysMethodResult, error) {
	methodArgs := argsToInterfaceDynamicArrayOfDynamicArrays(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "dynamicArrayOfDynamicArrays",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &DynamicArrayOfDynamicArraysMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([]uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendSubTest calls the subTest ABI method and waits for confirmation.
func (c *Client) SendSubTest(ctx context.Context) (*SubTestMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "subTest",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &SubTestMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([5]uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendShadowTest calls the shadowTest ABI method and waits for confirmation.
func (c *Client) SendShadowTest(ctx context.Context) (*ShadowTestMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "shadowTest",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ShadowTestMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendBoxSetTest calls the boxSetTest ABI method and waits for confirmation.
func (c *Client) SendBoxSetTest(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "boxSetTest",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendPaddedBytes calls the paddedBytes ABI method and waits for confirmation.
func (c *Client) SendPaddedBytes(ctx context.Context) (*PaddedBytesMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "paddedBytes",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &PaddedBytesMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([32]byte); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

func argsToInterfaceGetBox(args GetBoxArgs) []interface{} {
	return []interface{}{
		args.Offset,
	}
}

func argsToInterfaceRawState(args RawStateArgs) []interface{} {
	return []interface{}{
		args.App,
	}
}

func argsToInterfaceDecodeAppList(args DecodeAppListArgs) []interface{} {
	return []interface{}{
		args.App,
	}
}

func argsToInterfaceDecodeUint64(args DecodeUint64Args) []interface{} {
	return []interface{}{
		args.App,
	}
}

func argsToInterfaceDecodeStaticArray(args DecodeStaticArrayArgs) []interface{} {
	return []interface{}{
		args.App,
	}
}

func argsToInterfaceCheckObjectAssignment(args CheckObjectAssignmentArgs) []interface{} {
	return []interface{}{
		args.A,
		args.B,
	}
}

func argsToInterfaceDynamicArrayOfDynamicArrays(args DynamicArrayOfDynamicArraysArgs) []interface{} {
	return []interface{}{
		args.A,
		args.B,
		args.C,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
