// Code generated by algokit-client-generator-go. DO NOT EDIT.
package akitasocialgraph

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the AkitaSocialGraph smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendBlock calls the block ABI method and waits for confirmation.
func (c *Client) SendBlock(ctx context.Context, params algokit.CallParams[BlockArgs]) error {
	methodArgs := argsToInterfaceBlock(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "block",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUnblock calls the unblock ABI method and waits for confirmation.
func (c *Client) SendUnblock(ctx context.Context, params algokit.CallParams[UnblockArgs]) error {
	methodArgs := argsToInterfaceUnblock(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "unblock",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendGatedFollow calls the gatedFollow ABI method and waits for confirmation.
func (c *Client) SendGatedFollow(ctx context.Context, params algokit.CallParams[GatedFollowArgs]) error {
	methodArgs := argsToInterfaceGatedFollow(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "gatedFollow",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendFollow calls the follow ABI method and waits for confirmation.
func (c *Client) SendFollow(ctx context.Context, params algokit.CallParams[FollowArgs]) error {
	methodArgs := argsToInterfaceFollow(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "follow",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUnfollow calls the unfollow ABI method and waits for confirmation.
func (c *Client) SendUnfollow(ctx context.Context, params algokit.CallParams[UnfollowArgs]) error {
	methodArgs := argsToInterfaceUnfollow(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "unfollow",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendIsBlocked calls the isBlocked ABI method and waits for confirmation.
func (c *Client) SendIsBlocked(ctx context.Context, params algokit.CallParams[IsBlockedArgs]) (*IsBlockedMethodResult, error) {
	methodArgs := argsToInterfaceIsBlocked(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "isBlocked",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &IsBlockedMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendIsFollowing calls the isFollowing ABI method and waits for confirmation.
func (c *Client) SendIsFollowing(ctx context.Context, params algokit.CallParams[IsFollowingArgs]) (*IsFollowingMethodResult, error) {
	methodArgs := argsToInterfaceIsFollowing(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "isFollowing",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &IsFollowingMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendGetFollowIndex calls the getFollowIndex ABI method and waits for confirmation.
func (c *Client) SendGetFollowIndex(ctx context.Context, params algokit.CallParams[GetFollowIndexArgs]) (*GetFollowIndexMethodResult, error) {
	methodArgs := argsToInterfaceGetFollowIndex(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getFollowIndex",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetFollowIndexMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendMBR calls the mbr ABI method and waits for confirmation.
func (c *Client) SendMBR(ctx context.Context, params algokit.CallParams[MBRArgs]) (*MBRMethodResult, error) {
	methodArgs := argsToInterfaceMBR(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "mbr",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &MBRMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendPayWallMBR calls the payWallMbr ABI method and waits for confirmation.
func (c *Client) SendPayWallMBR(ctx context.Context, params algokit.CallParams[PayWallMBRArgs]) (*PayWallMBRMethodResult, error) {
	methodArgs := argsToInterfacePayWallMBR(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "payWallMbr",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &PayWallMBRMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendCheckTipMBRRequirements calls the checkTipMbrRequirements ABI method and waits for confirmation.
func (c *Client) SendCheckTipMBRRequirements(ctx context.Context, params algokit.CallParams[CheckTipMBRRequirementsArgs]) (*CheckTipMBRRequirementsMethodResult, error) {
	methodArgs := argsToInterfaceCheckTipMBRRequirements(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "checkTipMbrRequirements",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &CheckTipMBRRequirementsMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendUpdateAkitaDao calls the updateAkitaDAO ABI method and waits for confirmation.
func (c *Client) SendUpdateAkitaDao(ctx context.Context, params algokit.CallParams[UpdateAkitaDaoArgs]) error {
	methodArgs := argsToInterfaceUpdateAkitaDao(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "updateAkitaDAO",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendOpUp calls the opUp ABI method and waits for confirmation.
func (c *Client) SendOpUp(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "opUp",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

func argsToInterfaceCreate(args CreateArgs) []interface{} {
	return []interface{}{
		args.AkitaDao,
		args.Version,
	}
}

func argsToInterfaceBlock(args BlockArgs) []interface{} {
	return []interface{}{
		args.MBRPayment,
		args.Address,
	}
}

func argsToInterfaceUnblock(args UnblockArgs) []interface{} {
	return []interface{}{
		args.Address,
	}
}

func argsToInterfaceGatedFollow(args GatedFollowArgs) []interface{} {
	return []interface{}{
		args.MBRPayment,
		args.GateTXN,
		args.Address,
	}
}

func argsToInterfaceFollow(args FollowArgs) []interface{} {
	return []interface{}{
		args.MBRPayment,
		args.Address,
	}
}

func argsToInterfaceUnfollow(args UnfollowArgs) []interface{} {
	return []interface{}{
		args.Address,
	}
}

func argsToInterfaceIsBlocked(args IsBlockedArgs) []interface{} {
	return []interface{}{
		args.User,
		args.Blocked,
	}
}

func argsToInterfaceIsFollowing(args IsFollowingArgs) []interface{} {
	return []interface{}{
		args.Follower,
		args.User,
	}
}

func argsToInterfaceGetFollowIndex(args GetFollowIndexArgs) []interface{} {
	return []interface{}{
		args.Follower,
		args.User,
	}
}

func argsToInterfaceMBR(args MBRArgs) []interface{} {
	return []interface{}{
		args.Ref,
	}
}

func argsToInterfacePayWallMBR(args PayWallMBRArgs) []interface{} {
	return []interface{}{
		args.Paywall,
	}
}

func argsToInterfaceCheckTipMBRRequirements(args CheckTipMBRRequirementsArgs) []interface{} {
	return []interface{}{
		args.AkitaDao,
		args.Creator,
		args.Wallet,
	}
}

func argsToInterfaceUpdate(args UpdateArgs) []interface{} {
	return []interface{}{
		args.NewVersion,
	}
}

func argsToInterfaceUpdateAkitaDao(args UpdateAkitaDaoArgs) []interface{} {
	return []interface{}{
		args.AkitaDao,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
