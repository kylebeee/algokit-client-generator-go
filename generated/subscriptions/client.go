// Code generated by algokit-client-generator-go. DO NOT EDIT.
package subscriptions

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the Subscriptions smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendNewService calls the newService ABI method and waits for confirmation.
// newService creates a new service for a merchant
func (c *Client) SendNewService(ctx context.Context, params algokit.CallParams[NewServiceArgs]) (*NewServiceMethodResult, error) {
	methodArgs := argsToInterfaceNewService(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "newService",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &NewServiceMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendSetServiceDescription calls the setServiceDescription ABI method and waits for confirmation.
func (c *Client) SendSetServiceDescription(ctx context.Context, params algokit.CallParams[SetServiceDescriptionArgs]) error {
	methodArgs := argsToInterfaceSetServiceDescription(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "setServiceDescription",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendActivateService calls the activateService ABI method and waits for confirmation.
// activateService activates an service for a merchant
func (c *Client) SendActivateService(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "activateService",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendPauseService calls the pauseService ABI method and waits for confirmation.
// pauseService pauses a service for a merchant
// it does not shutdown pre-existing subscriptions
// it simply prevents new subscriptions from being created
// for a specific service
func (c *Client) SendPauseService(ctx context.Context, params algokit.CallParams[PauseServiceArgs]) error {
	methodArgs := argsToInterfacePauseService(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "pauseService",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUnpauseService calls the unpauseService ABI method and waits for confirmation.
// unpauseService activates an service for a merchant
func (c *Client) SendUnpauseService(ctx context.Context, params algokit.CallParams[UnpauseServiceArgs]) error {
	methodArgs := argsToInterfaceUnpauseService(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "unpauseService",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendShutdownService calls the shutdownService ABI method and waits for confirmation.
// shutdownService permanently shuts down an service for a merchant
// it also shutsdown pre-existing subscriptions
func (c *Client) SendShutdownService(ctx context.Context, params algokit.CallParams[ShutdownServiceArgs]) error {
	methodArgs := argsToInterfaceShutdownService(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "shutdownService",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendBlock calls the block ABI method and waits for confirmation.
// block blacklists an address for a merchant
func (c *Client) SendBlock(ctx context.Context, params algokit.CallParams[BlockArgs]) error {
	methodArgs := argsToInterfaceBlock(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "block",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUnblock calls the unblock ABI method and waits for confirmation.
// unblock removes an address from a merchants blocks
func (c *Client) SendUnblock(ctx context.Context, params algokit.CallParams[UnblockArgs]) error {
	methodArgs := argsToInterfaceUnblock(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "unblock",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendGatedSubscribe calls the gatedSubscribe ABI method and waits for confirmation.
func (c *Client) SendGatedSubscribe(ctx context.Context, params algokit.CallParams[GatedSubscribeArgs]) (*GatedSubscribeMethodResult, error) {
	methodArgs := argsToInterfaceGatedSubscribe(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "gatedSubscribe",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GatedSubscribeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendSubscribe calls the subscribe ABI method and waits for confirmation.
func (c *Client) SendSubscribe(ctx context.Context, params algokit.CallParams[SubscribeArgs]) (*SubscribeMethodResult, error) {
	methodArgs := argsToInterfaceSubscribe(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "subscribe",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &SubscribeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendGatedSubscribeASA calls the gatedSubscribeAsa ABI method and waits for confirmation.
func (c *Client) SendGatedSubscribeASA(ctx context.Context, params algokit.CallParams[GatedSubscribeASAArgs]) (*GatedSubscribeASAMethodResult, error) {
	methodArgs := argsToInterfaceGatedSubscribeASA(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "gatedSubscribeAsa",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GatedSubscribeASAMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendSubscribeASA calls the subscribeAsa ABI method and waits for confirmation.
func (c *Client) SendSubscribeASA(ctx context.Context, params algokit.CallParams[SubscribeASAArgs]) (*SubscribeASAMethodResult, error) {
	methodArgs := argsToInterfaceSubscribeASA(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "subscribeAsa",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &SubscribeASAMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendDeposit calls the deposit ABI method and waits for confirmation.
func (c *Client) SendDeposit(ctx context.Context, params algokit.CallParams[DepositArgs]) error {
	methodArgs := argsToInterfaceDeposit(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "deposit",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendDepositASA calls the depositAsa ABI method and waits for confirmation.
func (c *Client) SendDepositASA(ctx context.Context, params algokit.CallParams[DepositASAArgs]) error {
	methodArgs := argsToInterfaceDepositASA(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "depositAsa",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendWithdraw calls the withdraw ABI method and waits for confirmation.
func (c *Client) SendWithdraw(ctx context.Context, params algokit.CallParams[WithdrawArgs]) error {
	methodArgs := argsToInterfaceWithdraw(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "withdraw",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUnsubscribe calls the unsubscribe ABI method and waits for confirmation.
func (c *Client) SendUnsubscribe(ctx context.Context, params algokit.CallParams[UnsubscribeArgs]) error {
	methodArgs := argsToInterfaceUnsubscribe(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "unsubscribe",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendGatedTriggerPayment calls the gatedTriggerPayment ABI method and waits for confirmation.
func (c *Client) SendGatedTriggerPayment(ctx context.Context, params algokit.CallParams[GatedTriggerPaymentArgs]) error {
	methodArgs := argsToInterfaceGatedTriggerPayment(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "gatedTriggerPayment",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendTriggerPayment calls the triggerPayment ABI method and waits for confirmation.
func (c *Client) SendTriggerPayment(ctx context.Context, params algokit.CallParams[TriggerPaymentArgs]) error {
	methodArgs := argsToInterfaceTriggerPayment(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "triggerPayment",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendStreakCheck calls the streakCheck ABI method and waits for confirmation.
func (c *Client) SendStreakCheck(ctx context.Context, params algokit.CallParams[StreakCheckArgs]) error {
	methodArgs := argsToInterfaceStreakCheck(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "streakCheck",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendSetPasses calls the setPasses ABI method and waits for confirmation.
func (c *Client) SendSetPasses(ctx context.Context, params algokit.CallParams[SetPassesArgs]) error {
	methodArgs := argsToInterfaceSetPasses(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "setPasses",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendTriggerList calls the triggerList ABI method and waits for confirmation.
func (c *Client) SendTriggerList(ctx context.Context, params algokit.CallParams[TriggerListArgs]) (*TriggerListMethodResult, error) {
	methodArgs := argsToInterfaceTriggerList(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "triggerList",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &TriggerListMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([]bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendIsBlocked calls the isBlocked ABI method and waits for confirmation.
// isBlocked checks if an address is blocked for a merchant
func (c *Client) SendIsBlocked(ctx context.Context, params algokit.CallParams[IsBlockedArgs]) (*IsBlockedMethodResult, error) {
	methodArgs := argsToInterfaceIsBlocked(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "isBlocked",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &IsBlockedMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendIsShutdown calls the isShutdown ABI method and waits for confirmation.
// serviceIsActive checks if an service is shutdown
func (c *Client) SendIsShutdown(ctx context.Context, params algokit.CallParams[IsShutdownArgs]) (*IsShutdownMethodResult, error) {
	methodArgs := argsToInterfaceIsShutdown(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "isShutdown",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &IsShutdownMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendNewServiceCost calls the newServiceCost ABI method and waits for confirmation.
func (c *Client) SendNewServiceCost(ctx context.Context, params algokit.CallParams[NewServiceCostArgs]) (*NewServiceCostMethodResult, error) {
	methodArgs := argsToInterfaceNewServiceCost(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "newServiceCost",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &NewServiceCostMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendNewSubscriptionCost calls the newSubscriptionCost ABI method and waits for confirmation.
func (c *Client) SendNewSubscriptionCost(ctx context.Context, params algokit.CallParams[NewSubscriptionCostArgs]) (*NewSubscriptionCostMethodResult, error) {
	methodArgs := argsToInterfaceNewSubscriptionCost(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "newSubscriptionCost",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &NewSubscriptionCostMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendBlockCost calls the blockCost ABI method and waits for confirmation.
func (c *Client) SendBlockCost(ctx context.Context) (*BlockCostMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "blockCost",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &BlockCostMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendGetService calls the getService ABI method and waits for confirmation.
func (c *Client) SendGetService(ctx context.Context, params algokit.CallParams[GetServiceArgs]) (*GetServiceMethodResult, error) {
	methodArgs := argsToInterfaceGetService(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getService",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetServiceMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendGetServicesByAddress calls the getServicesByAddress ABI method and waits for confirmation.
func (c *Client) SendGetServicesByAddress(ctx context.Context, params algokit.CallParams[GetServicesByAddressArgs]) (*GetServicesByAddressMethodResult, error) {
	methodArgs := argsToInterfaceGetServicesByAddress(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getServicesByAddress",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetServicesByAddressMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.([][]interface{}); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendGetSubscription calls the getSubscription ABI method and waits for confirmation.
func (c *Client) SendGetSubscription(ctx context.Context, params algokit.CallParams[GetSubscriptionArgs]) (*GetSubscriptionMethodResult, error) {
	methodArgs := argsToInterfaceGetSubscription(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getSubscription",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetSubscriptionMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendMustGetSubscription calls the mustGetSubscription ABI method and waits for confirmation.
func (c *Client) SendMustGetSubscription(ctx context.Context, params algokit.CallParams[MustGetSubscriptionArgs]) (*MustGetSubscriptionMethodResult, error) {
	methodArgs := argsToInterfaceMustGetSubscription(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "mustGetSubscription",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &MustGetSubscriptionMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendGetSubscriptionWithDetails calls the getSubscriptionWithDetails ABI method and waits for confirmation.
func (c *Client) SendGetSubscriptionWithDetails(ctx context.Context, params algokit.CallParams[GetSubscriptionWithDetailsArgs]) (*GetSubscriptionWithDetailsMethodResult, error) {
	methodArgs := argsToInterfaceGetSubscriptionWithDetails(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getSubscriptionWithDetails",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetSubscriptionWithDetailsMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendIsFirstSubscription calls the isFirstSubscription ABI method and waits for confirmation.
func (c *Client) SendIsFirstSubscription(ctx context.Context, params algokit.CallParams[IsFirstSubscriptionArgs]) (*IsFirstSubscriptionMethodResult, error) {
	methodArgs := argsToInterfaceIsFirstSubscription(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "isFirstSubscription",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &IsFirstSubscriptionMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendGetServiceList calls the getServiceList ABI method and waits for confirmation.
func (c *Client) SendGetServiceList(ctx context.Context, params algokit.CallParams[GetServiceListArgs]) (*GetServiceListMethodResult, error) {
	methodArgs := argsToInterfaceGetServiceList(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getServiceList",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetServiceListMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendGetSubscriptionList calls the getSubscriptionList ABI method and waits for confirmation.
func (c *Client) SendGetSubscriptionList(ctx context.Context, params algokit.CallParams[GetSubscriptionListArgs]) (*GetSubscriptionListMethodResult, error) {
	methodArgs := argsToInterfaceGetSubscriptionList(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getSubscriptionList",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetSubscriptionListMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendOptIn calls the optIn ABI method and waits for confirmation.
// optin tells the contract to opt into an asa
func (c *Client) SendOptIn(ctx context.Context, params algokit.CallParams[OptInArgs]) error {
	methodArgs := argsToInterfaceOptIn(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "optIn",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendOptInCost calls the optInCost ABI method and waits for confirmation.
func (c *Client) SendOptInCost(ctx context.Context, params algokit.CallParams[OptInCostArgs]) (*OptInCostMethodResult, error) {
	methodArgs := argsToInterfaceOptInCost(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "optInCost",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &OptInCostMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendUpdateAkitaDaoEscrow calls the updateAkitaDAOEscrow ABI method and waits for confirmation.
func (c *Client) SendUpdateAkitaDaoEscrow(ctx context.Context, params algokit.CallParams[UpdateAkitaDaoEscrowArgs]) error {
	methodArgs := argsToInterfaceUpdateAkitaDaoEscrow(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "updateAkitaDAOEscrow",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUpdateAkitaDao calls the updateAkitaDAO ABI method and waits for confirmation.
func (c *Client) SendUpdateAkitaDao(ctx context.Context, params algokit.CallParams[UpdateAkitaDaoArgs]) error {
	methodArgs := argsToInterfaceUpdateAkitaDao(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "updateAkitaDAO",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendOpUp calls the opUp ABI method and waits for confirmation.
func (c *Client) SendOpUp(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "opUp",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

func argsToInterfaceCreate(args CreateArgs) []interface{} {
	return []interface{}{
		args.Version,
		args.AkitaDao,
		args.AkitaDaoEscrow,
	}
}

func argsToInterfaceNewService(args NewServiceArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Interval,
		args.Asset,
		args.Amount,
		args.Passes,
		args.GateID,
		args.Title,
		args.BannerImage,
		args.HighlightMessage,
		args.HighlightColor,
	}
}

func argsToInterfaceSetServiceDescription(args SetServiceDescriptionArgs) []interface{} {
	return []interface{}{
		args.Offset,
		args.Data,
	}
}

func argsToInterfacePauseService(args PauseServiceArgs) []interface{} {
	return []interface{}{
		args.ID,
	}
}

func argsToInterfaceUnpauseService(args UnpauseServiceArgs) []interface{} {
	return []interface{}{
		args.ID,
	}
}

func argsToInterfaceShutdownService(args ShutdownServiceArgs) []interface{} {
	return []interface{}{
		args.ID,
	}
}

func argsToInterfaceBlock(args BlockArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Blocked,
	}
}

func argsToInterfaceUnblock(args UnblockArgs) []interface{} {
	return []interface{}{
		args.Blocked,
	}
}

func argsToInterfaceGatedSubscribe(args GatedSubscribeArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.GateTXN,
		args.Recipient,
		args.Amount,
		args.Interval,
		args.ServiceID,
	}
}

func argsToInterfaceSubscribe(args SubscribeArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Recipient,
		args.Amount,
		args.Interval,
		args.ServiceID,
	}
}

func argsToInterfaceGatedSubscribeASA(args GatedSubscribeASAArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.AssetXfer,
		args.GateTXN,
		args.Recipient,
		args.Amount,
		args.Interval,
		args.ServiceID,
	}
}

func argsToInterfaceSubscribeASA(args SubscribeASAArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.AssetXfer,
		args.Recipient,
		args.Amount,
		args.Interval,
		args.ServiceID,
	}
}

func argsToInterfaceDeposit(args DepositArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.ID,
	}
}

func argsToInterfaceDepositASA(args DepositASAArgs) []interface{} {
	return []interface{}{
		args.AssetXfer,
		args.ID,
	}
}

func argsToInterfaceWithdraw(args WithdrawArgs) []interface{} {
	return []interface{}{
		args.ID,
		args.Amount,
	}
}

func argsToInterfaceUnsubscribe(args UnsubscribeArgs) []interface{} {
	return []interface{}{
		args.ID,
	}
}

func argsToInterfaceGatedTriggerPayment(args GatedTriggerPaymentArgs) []interface{} {
	return []interface{}{
		args.GateTXN,
		args.Key,
	}
}

func argsToInterfaceTriggerPayment(args TriggerPaymentArgs) []interface{} {
	return []interface{}{
		args.Key,
	}
}

func argsToInterfaceStreakCheck(args StreakCheckArgs) []interface{} {
	return []interface{}{
		args.Key,
	}
}

func argsToInterfaceSetPasses(args SetPassesArgs) []interface{} {
	return []interface{}{
		args.ID,
		args.Addresses,
	}
}

func argsToInterfaceTriggerList(args TriggerListArgs) []interface{} {
	return []interface{}{
		args.Req,
	}
}

func argsToInterfaceIsBlocked(args IsBlockedArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.Blocked,
	}
}

func argsToInterfaceIsShutdown(args IsShutdownArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.ID,
	}
}

func argsToInterfaceNewServiceCost(args NewServiceCostArgs) []interface{} {
	return []interface{}{
		args.Asset,
	}
}

func argsToInterfaceNewSubscriptionCost(args NewSubscriptionCostArgs) []interface{} {
	return []interface{}{
		args.Recipient,
		args.Asset,
		args.ServiceID,
	}
}

func argsToInterfaceGetService(args GetServiceArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.ID,
	}
}

func argsToInterfaceGetServicesByAddress(args GetServicesByAddressArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.Start,
		args.WindowSize,
	}
}

func argsToInterfaceGetSubscription(args GetSubscriptionArgs) []interface{} {
	return []interface{}{
		args.Key,
	}
}

func argsToInterfaceMustGetSubscription(args MustGetSubscriptionArgs) []interface{} {
	return []interface{}{
		args.Key,
	}
}

func argsToInterfaceGetSubscriptionWithDetails(args GetSubscriptionWithDetailsArgs) []interface{} {
	return []interface{}{
		args.Key,
	}
}

func argsToInterfaceIsFirstSubscription(args IsFirstSubscriptionArgs) []interface{} {
	return []interface{}{
		args.Address,
	}
}

func argsToInterfaceGetServiceList(args GetServiceListArgs) []interface{} {
	return []interface{}{
		args.Address,
	}
}

func argsToInterfaceGetSubscriptionList(args GetSubscriptionListArgs) []interface{} {
	return []interface{}{
		args.Address,
	}
}

func argsToInterfaceOptIn(args OptInArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Asset,
	}
}

func argsToInterfaceOptInCost(args OptInCostArgs) []interface{} {
	return []interface{}{
		args.Asset,
	}
}

func argsToInterfaceUpdateAkitaDaoEscrow(args UpdateAkitaDaoEscrowArgs) []interface{} {
	return []interface{}{
		args.App,
	}
}

func argsToInterfaceUpdate(args UpdateArgs) []interface{} {
	return []interface{}{
		args.NewVersion,
	}
}

func argsToInterfaceUpdateAkitaDao(args UpdateAkitaDaoArgs) []interface{} {
	return []interface{}{
		args.AkitaDao,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
