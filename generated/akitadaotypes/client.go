// Code generated by algokit-client-generator-go. DO NOT EDIT.
package akitadaotypes

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the AkitaDaoTypes smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendProposalUpgradeAppShape calls the proposalUpgradeAppShape ABI method and waits for confirmation.
func (c *Client) SendProposalUpgradeAppShape(ctx context.Context, params algokit.CallParams[ProposalUpgradeAppShapeArgs]) (*ProposalUpgradeAppShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalUpgradeAppShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalUpgradeAppShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalUpgradeAppShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalAddPluginShape calls the proposalAddPluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalAddPluginShape(ctx context.Context, params algokit.CallParams[ProposalAddPluginShapeArgs]) (*ProposalAddPluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalAddPluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalAddPluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalAddPluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalAddNamedPluginShape calls the proposalAddNamedPluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalAddNamedPluginShape(ctx context.Context, params algokit.CallParams[ProposalAddNamedPluginShapeArgs]) (*ProposalAddNamedPluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalAddNamedPluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalAddNamedPluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalAddNamedPluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalRemovePluginShape calls the proposalRemovePluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalRemovePluginShape(ctx context.Context, params algokit.CallParams[ProposalRemovePluginShapeArgs]) (*ProposalRemovePluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalRemovePluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalRemovePluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalRemovePluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalRemoveNamedPluginShape calls the proposalRemoveNamedPluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalRemoveNamedPluginShape(ctx context.Context, params algokit.CallParams[ProposalRemoveNamedPluginShapeArgs]) (*ProposalRemoveNamedPluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalRemoveNamedPluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalRemoveNamedPluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalRemoveNamedPluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalExecutePluginShape calls the proposalExecutePluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalExecutePluginShape(ctx context.Context, params algokit.CallParams[ProposalExecutePluginShapeArgs]) (*ProposalExecutePluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalExecutePluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalExecutePluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalExecutePluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalExecuteNamedPluginShape calls the proposalExecuteNamedPluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalExecuteNamedPluginShape(ctx context.Context, params algokit.CallParams[ProposalExecuteNamedPluginShapeArgs]) (*ProposalExecuteNamedPluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalExecuteNamedPluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalExecuteNamedPluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalExecuteNamedPluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalRemoveExecutePluginShape calls the proposalRemoveExecutePluginShape ABI method and waits for confirmation.
func (c *Client) SendProposalRemoveExecutePluginShape(ctx context.Context, params algokit.CallParams[ProposalRemoveExecutePluginShapeArgs]) (*ProposalRemoveExecutePluginShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalRemoveExecutePluginShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalRemoveExecutePluginShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalRemoveExecutePluginShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalAddAllowancesShape calls the proposalAddAllowancesShape ABI method and waits for confirmation.
func (c *Client) SendProposalAddAllowancesShape(ctx context.Context, params algokit.CallParams[ProposalAddAllowancesShapeArgs]) (*ProposalAddAllowancesShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalAddAllowancesShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalAddAllowancesShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalAddAllowancesShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalRemoveAllowancesShape calls the proposalRemoveAllowancesShape ABI method and waits for confirmation.
func (c *Client) SendProposalRemoveAllowancesShape(ctx context.Context, params algokit.CallParams[ProposalRemoveAllowancesShapeArgs]) (*ProposalRemoveAllowancesShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalRemoveAllowancesShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalRemoveAllowancesShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalRemoveAllowancesShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalNewEscrowShape calls the proposalNewEscrowShape ABI method and waits for confirmation.
func (c *Client) SendProposalNewEscrowShape(ctx context.Context, params algokit.CallParams[ProposalNewEscrowShapeArgs]) (*ProposalNewEscrowShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalNewEscrowShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalNewEscrowShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalNewEscrowShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalToggleEscrowLockShape calls the proposalToggleEscrowLockShape ABI method and waits for confirmation.
func (c *Client) SendProposalToggleEscrowLockShape(ctx context.Context, params algokit.CallParams[ProposalToggleEscrowLockShapeArgs]) (*ProposalToggleEscrowLockShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalToggleEscrowLockShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalToggleEscrowLockShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalToggleEscrowLockShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendProposalUpdateFieldShape calls the proposalUpdateFieldShape ABI method and waits for confirmation.
func (c *Client) SendProposalUpdateFieldShape(ctx context.Context, params algokit.CallParams[ProposalUpdateFieldShapeArgs]) (*ProposalUpdateFieldShapeMethodResult, error) {
	methodArgs := argsToInterfaceProposalUpdateFieldShape(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalUpdateFieldShape",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalUpdateFieldShapeMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

func argsToInterfaceProposalUpgradeAppShape(args ProposalUpgradeAppShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalAddPluginShape(args ProposalAddPluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalAddNamedPluginShape(args ProposalAddNamedPluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalRemovePluginShape(args ProposalRemovePluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalRemoveNamedPluginShape(args ProposalRemoveNamedPluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalExecutePluginShape(args ProposalExecutePluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalExecuteNamedPluginShape(args ProposalExecuteNamedPluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalRemoveExecutePluginShape(args ProposalRemoveExecutePluginShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalAddAllowancesShape(args ProposalAddAllowancesShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalRemoveAllowancesShape(args ProposalRemoveAllowancesShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalNewEscrowShape(args ProposalNewEscrowShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalToggleEscrowLockShape(args ProposalToggleEscrowLockShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

func argsToInterfaceProposalUpdateFieldShape(args ProposalUpdateFieldShapeArgs) []interface{} {
	return []interface{}{
		args.Shape,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
