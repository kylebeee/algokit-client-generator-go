// Code generated by algokit-client-generator-go. DO NOT EDIT.
package metamerkles

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the MetaMerkles smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendAddRoot calls the addRoot ABI method and waits for confirmation.
// Creates two boxes and adds a merkle root
// using a `RootKey` to the root box map and also a list type to the
// metadata attached to the root in the data box map
func (c *Client) SendAddRoot(ctx context.Context, params algokit.CallParams[AddRootArgs]) error {
	methodArgs := argsToInterfaceAddRoot(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "addRoot",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendDeleteRoot calls the deleteRoot ABI method and waits for confirmation.
// Deletes the merkle root from the root box map
func (c *Client) SendDeleteRoot(ctx context.Context, params algokit.CallParams[DeleteRootArgs]) error {
	methodArgs := argsToInterfaceDeleteRoot(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "deleteRoot",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUpdateRoot calls the updateRoot ABI method and waits for confirmation.
// Replaces the merkle root with another
func (c *Client) SendUpdateRoot(ctx context.Context, params algokit.CallParams[UpdateRootArgs]) error {
	methodArgs := argsToInterfaceUpdateRoot(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "updateRoot",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendAddData calls the addData ABI method and waits for confirmation.
// Registers a key & value in the data box map that
// corresponds to a merkle root in the root box map
func (c *Client) SendAddData(ctx context.Context, params algokit.CallParams[AddDataArgs]) error {
	methodArgs := argsToInterfaceAddData(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "addData",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendDeleteData calls the deleteData ABI method and waits for confirmation.
// Deletes a metadata key & value pair from the data box map
func (c *Client) SendDeleteData(ctx context.Context, params algokit.CallParams[DeleteDataArgs]) error {
	methodArgs := argsToInterfaceDeleteData(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "deleteData",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendVerify calls the verify ABI method and waits for confirmation.
// verify an inclusion in a double sha256 based merkle tree
func (c *Client) SendVerify(ctx context.Context, params algokit.CallParams[VerifyArgs]) (*VerifyMethodResult, error) {
	methodArgs := argsToInterfaceVerify(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "verify",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &VerifyMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(bool); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendRead calls the read ABI method and waits for confirmation.
// Fetch a metadata properties
func (c *Client) SendRead(ctx context.Context, params algokit.CallParams[ReadArgs]) (*ReadMethodResult, error) {
	methodArgs := argsToInterfaceRead(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "read",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ReadMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(string); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendVerifiedRead calls the verifiedRead ABI method and waits for confirmation.
// Read metadata from box storage and verify the data provided is included
// in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
// thats pre-computed off chain.
//
// verify an inclusion in a merkle tree
// & read an associated key value pair
// & check against the underlying data's schema
// & check against the underlying data's list type or purpose
func (c *Client) SendVerifiedRead(ctx context.Context, params algokit.CallParams[VerifiedReadArgs]) (*VerifiedReadMethodResult, error) {
	methodArgs := argsToInterfaceVerifiedRead(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "verifiedRead",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &VerifiedReadMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(string); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendVerifiedMustRead calls the verifiedMustRead ABI method and waits for confirmation.
// Read metadata from box storage and verify the data provided is included
// in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
// thats pre-computed off chain.
//
// verify an inclusion in a merkle tree
// & read an associated key value pair
// & check against the underlying data's schema
// & check against the underlying data's list type or purpose
func (c *Client) SendVerifiedMustRead(ctx context.Context, params algokit.CallParams[VerifiedMustReadArgs]) (*VerifiedMustReadMethodResult, error) {
	methodArgs := argsToInterfaceVerifiedMustRead(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "verifiedMustRead",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &VerifiedMustReadMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(string); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendAddType calls the addType ABI method and waits for confirmation.
func (c *Client) SendAddType(ctx context.Context, params algokit.CallParams[AddTypeArgs]) error {
	methodArgs := argsToInterfaceAddType(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "addType",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendRootCosts calls the rootCosts ABI method and waits for confirmation.
func (c *Client) SendRootCosts(ctx context.Context, params algokit.CallParams[RootCostsArgs]) (*RootCostsMethodResult, error) {
	methodArgs := argsToInterfaceRootCosts(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "rootCosts",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &RootCostsMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendDataCosts calls the dataCosts ABI method and waits for confirmation.
func (c *Client) SendDataCosts(ctx context.Context, params algokit.CallParams[DataCostsArgs]) (*DataCostsMethodResult, error) {
	methodArgs := argsToInterfaceDataCosts(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "dataCosts",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &DataCostsMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

func argsToInterfaceAddRoot(args AddRootArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Name,
		args.Root,
		args.Type,
	}
}

func argsToInterfaceDeleteRoot(args DeleteRootArgs) []interface{} {
	return []interface{}{
		args.Name,
	}
}

func argsToInterfaceUpdateRoot(args UpdateRootArgs) []interface{} {
	return []interface{}{
		args.Name,
		args.NewRoot,
	}
}

func argsToInterfaceAddData(args AddDataArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Name,
		args.Key,
		args.Value,
	}
}

func argsToInterfaceDeleteData(args DeleteDataArgs) []interface{} {
	return []interface{}{
		args.Name,
		args.Key,
	}
}

func argsToInterfaceVerify(args VerifyArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.Name,
		args.Leaf,
		args.Proof,
		args.Type,
	}
}

func argsToInterfaceRead(args ReadArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.Name,
		args.Key,
	}
}

func argsToInterfaceVerifiedRead(args VerifiedReadArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.Name,
		args.Leaf,
		args.Proof,
		args.Type,
		args.Key,
	}
}

func argsToInterfaceVerifiedMustRead(args VerifiedMustReadArgs) []interface{} {
	return []interface{}{
		args.Address,
		args.Name,
		args.Leaf,
		args.Proof,
		args.Type,
		args.Key,
	}
}

func argsToInterfaceAddType(args AddTypeArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Description,
		args.SchemaList,
	}
}

func argsToInterfaceRootCosts(args RootCostsArgs) []interface{} {
	return []interface{}{
		args.Name,
	}
}

func argsToInterfaceDataCosts(args DataCostsArgs) []interface{} {
	return []interface{}{
		args.Name,
		args.Key,
		args.Value,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
