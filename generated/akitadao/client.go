// Code generated by algokit-client-generator-go. DO NOT EDIT.
package akitadao

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the AkitaDao smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendSetup calls the setup ABI method and waits for confirmation.
func (c *Client) SendSetup(ctx context.Context, params algokit.CallParams[SetupArgs]) (*SetupMethodResult, error) {
	methodArgs := argsToInterfaceSetup(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "setup",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &SetupMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendPartiallyInitialize calls the partiallyInitialize ABI method and waits for confirmation.
func (c *Client) SendPartiallyInitialize(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "partiallyInitialize",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendInitialize calls the initialize ABI method and waits for confirmation.
func (c *Client) SendInitialize(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "initialize",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendNewProposal calls the newProposal ABI method and waits for confirmation.
func (c *Client) SendNewProposal(ctx context.Context, params algokit.CallParams[NewProposalArgs]) (*NewProposalMethodResult, error) {
	methodArgs := argsToInterfaceNewProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "newProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &NewProposalMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendEditProposal calls the editProposal ABI method and waits for confirmation.
func (c *Client) SendEditProposal(ctx context.Context, params algokit.CallParams[EditProposalArgs]) error {
	methodArgs := argsToInterfaceEditProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "editProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendEditProposalWithPayment calls the editProposalWithPayment ABI method and waits for confirmation.
func (c *Client) SendEditProposalWithPayment(ctx context.Context, params algokit.CallParams[EditProposalWithPaymentArgs]) error {
	methodArgs := argsToInterfaceEditProposalWithPayment(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "editProposalWithPayment",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendDeleteProposal calls the deleteProposal ABI method and waits for confirmation.
func (c *Client) SendDeleteProposal(ctx context.Context, params algokit.CallParams[DeleteProposalArgs]) error {
	methodArgs := argsToInterfaceDeleteProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "deleteProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendSubmitProposal calls the submitProposal ABI method and waits for confirmation.
func (c *Client) SendSubmitProposal(ctx context.Context, params algokit.CallParams[SubmitProposalArgs]) error {
	methodArgs := argsToInterfaceSubmitProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "submitProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendVoteProposal calls the voteProposal ABI method and waits for confirmation.
func (c *Client) SendVoteProposal(ctx context.Context, params algokit.CallParams[VoteProposalArgs]) error {
	methodArgs := argsToInterfaceVoteProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "voteProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendFinalizeProposal calls the finalizeProposal ABI method and waits for confirmation.
func (c *Client) SendFinalizeProposal(ctx context.Context, params algokit.CallParams[FinalizeProposalArgs]) error {
	methodArgs := argsToInterfaceFinalizeProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "finalizeProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendExecuteProposal calls the executeProposal ABI method and waits for confirmation.
func (c *Client) SendExecuteProposal(ctx context.Context, params algokit.CallParams[ExecuteProposalArgs]) error {
	methodArgs := argsToInterfaceExecuteProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "executeProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendDeleteProposalVotes calls the deleteProposalVotes ABI method and waits for confirmation.
func (c *Client) SendDeleteProposalVotes(ctx context.Context, params algokit.CallParams[DeleteProposalVotesArgs]) error {
	methodArgs := argsToInterfaceDeleteProposalVotes(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "deleteProposalVotes",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendSetupCost calls the setupCost ABI method and waits for confirmation.
func (c *Client) SendSetupCost(ctx context.Context) (*SetupCostMethodResult, error) {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "setupCost",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &SetupCostMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if val, ok := result.ABIReturn.(uint64); ok {
			typedResult.Return = val
		}
	}

	return typedResult, nil
}

// SendProposalCost calls the proposalCost ABI method and waits for confirmation.
func (c *Client) SendProposalCost(ctx context.Context, params algokit.CallParams[ProposalCostArgs]) (*ProposalCostMethodResult, error) {
	methodArgs := argsToInterfaceProposalCost(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "proposalCost",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &ProposalCostMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendGetProposal calls the getProposal ABI method and waits for confirmation.
func (c *Client) SendGetProposal(ctx context.Context, params algokit.CallParams[GetProposalArgs]) (*GetProposalMethodResult, error) {
	methodArgs := argsToInterfaceGetProposal(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "getProposal",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &GetProposalMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendMustGetExecution calls the mustGetExecution ABI method and waits for confirmation.
func (c *Client) SendMustGetExecution(ctx context.Context, params algokit.CallParams[MustGetExecutionArgs]) (*MustGetExecutionMethodResult, error) {
	methodArgs := argsToInterfaceMustGetExecution(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "mustGetExecution",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return nil, err
	}

	typedResult := &MustGetExecutionMethodResult{
		SendAppTransactionResult: *result,
	}

	if result.ABIReturn != nil {
		if vals, ok := result.ABIReturn.([]interface{}); ok {
			if err := algokit.TupleToStruct(vals, &typedResult.Return); err != nil {
				return nil, fmt.Errorf("failed to decode return: %w", err)
			}
		}
	}

	return typedResult, nil
}

// SendOpUp calls the opUp ABI method and waits for confirmation.
func (c *Client) SendOpUp(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "opUp",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

func argsToInterfaceCreate(args CreateArgs) []interface{} {
	return []interface{}{
		args.Version,
		args.Akta,
		args.ContentPolicy,
		args.MinRewardsImpact,
		args.Apps,
		args.Fees,
		args.ProposalSettings,
		args.RevenueSplits,
	}
}

func argsToInterfaceUpdate(args UpdateArgs) []interface{} {
	return []interface{}{
		args.NewVersion,
	}
}

func argsToInterfaceSetup(args SetupArgs) []interface{} {
	return []interface{}{
		args.Nickname,
	}
}

func argsToInterfaceNewProposal(args NewProposalArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.Cid,
		args.Actions,
	}
}

func argsToInterfaceEditProposal(args EditProposalArgs) []interface{} {
	return []interface{}{
		args.ID,
		args.Cid,
		args.Actions,
	}
}

func argsToInterfaceEditProposalWithPayment(args EditProposalWithPaymentArgs) []interface{} {
	return []interface{}{
		args.Payment,
		args.ID,
		args.Cid,
		args.Actions,
	}
}

func argsToInterfaceDeleteProposal(args DeleteProposalArgs) []interface{} {
	return []interface{}{
		args.ProposalID,
	}
}

func argsToInterfaceSubmitProposal(args SubmitProposalArgs) []interface{} {
	return []interface{}{
		args.ProposalID,
	}
}

func argsToInterfaceVoteProposal(args VoteProposalArgs) []interface{} {
	return []interface{}{
		args.MBRPayment,
		args.ProposalID,
		args.Vote,
	}
}

func argsToInterfaceFinalizeProposal(args FinalizeProposalArgs) []interface{} {
	return []interface{}{
		args.ProposalID,
	}
}

func argsToInterfaceExecuteProposal(args ExecuteProposalArgs) []interface{} {
	return []interface{}{
		args.ProposalID,
	}
}

func argsToInterfaceDeleteProposalVotes(args DeleteProposalVotesArgs) []interface{} {
	return []interface{}{
		args.ProposalID,
		args.Voters,
	}
}

func argsToInterfaceProposalCost(args ProposalCostArgs) []interface{} {
	return []interface{}{
		args.Actions,
	}
}

func argsToInterfaceGetProposal(args GetProposalArgs) []interface{} {
	return []interface{}{
		args.ProposalID,
	}
}

func argsToInterfaceMustGetExecution(args MustGetExecutionArgs) []interface{} {
	return []interface{}{
		args.Lease,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
