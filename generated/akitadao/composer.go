// Code generated by algokit-client-generator-go. DO NOT EDIT.
package akitadao

import (
	"context"

	algokit "github.com/kylebeee/algokit-utils-go"
)

// Composer builds atomic transaction groups for the AkitaDao contract.
type Composer struct {
	client   *Client
	composer *algokit.TransactionComposer
}

// Setup adds a setup method call to the transaction group.
func (comp *Composer) Setup(ctx context.Context, params algokit.CallParams[SetupArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceSetup(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "setup" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// PartiallyInitialize adds a partiallyInitialize method call to the transaction group.
func (comp *Composer) PartiallyInitialize(ctx context.Context) (*Composer, error) {
	methodArgs := []interface{}(nil)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "partiallyInitialize" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:      comp.client.AppID(),
		Method:     method,
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// Initialize adds a initialize method call to the transaction group.
func (comp *Composer) Initialize(ctx context.Context) (*Composer, error) {
	methodArgs := []interface{}(nil)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "initialize" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:      comp.client.AppID(),
		Method:     method,
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// NewProposal adds a newProposal method call to the transaction group.
func (comp *Composer) NewProposal(ctx context.Context, params algokit.CallParams[NewProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceNewProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "newProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// EditProposal adds a editProposal method call to the transaction group.
func (comp *Composer) EditProposal(ctx context.Context, params algokit.CallParams[EditProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceEditProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "editProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// EditProposalWithPayment adds a editProposalWithPayment method call to the transaction group.
func (comp *Composer) EditProposalWithPayment(ctx context.Context, params algokit.CallParams[EditProposalWithPaymentArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceEditProposalWithPayment(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "editProposalWithPayment" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// DeleteProposal adds a deleteProposal method call to the transaction group.
func (comp *Composer) DeleteProposal(ctx context.Context, params algokit.CallParams[DeleteProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceDeleteProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "deleteProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// SubmitProposal adds a submitProposal method call to the transaction group.
func (comp *Composer) SubmitProposal(ctx context.Context, params algokit.CallParams[SubmitProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceSubmitProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "submitProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// VoteProposal adds a voteProposal method call to the transaction group.
func (comp *Composer) VoteProposal(ctx context.Context, params algokit.CallParams[VoteProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceVoteProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "voteProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// FinalizeProposal adds a finalizeProposal method call to the transaction group.
func (comp *Composer) FinalizeProposal(ctx context.Context, params algokit.CallParams[FinalizeProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceFinalizeProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "finalizeProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// ExecuteProposal adds a executeProposal method call to the transaction group.
func (comp *Composer) ExecuteProposal(ctx context.Context, params algokit.CallParams[ExecuteProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceExecuteProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "executeProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// DeleteProposalVotes adds a deleteProposalVotes method call to the transaction group.
func (comp *Composer) DeleteProposalVotes(ctx context.Context, params algokit.CallParams[DeleteProposalVotesArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceDeleteProposalVotes(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "deleteProposalVotes" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// SetupCost adds a setupCost method call to the transaction group.
func (comp *Composer) SetupCost(ctx context.Context) (*Composer, error) {
	methodArgs := []interface{}(nil)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "setupCost" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:      comp.client.AppID(),
		Method:     method,
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// ProposalCost adds a proposalCost method call to the transaction group.
func (comp *Composer) ProposalCost(ctx context.Context, params algokit.CallParams[ProposalCostArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceProposalCost(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "proposalCost" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetProposal adds a getProposal method call to the transaction group.
func (comp *Composer) GetProposal(ctx context.Context, params algokit.CallParams[GetProposalArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetProposal(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getProposal" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// MustGetExecution adds a mustGetExecution method call to the transaction group.
func (comp *Composer) MustGetExecution(ctx context.Context, params algokit.CallParams[MustGetExecutionArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceMustGetExecution(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "mustGetExecution" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// OpUp adds a opUp method call to the transaction group.
func (comp *Composer) OpUp(ctx context.Context) (*Composer, error) {
	methodArgs := []interface{}(nil)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "opUp" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:      comp.client.AppID(),
		Method:     method,
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// Send executes the composed transaction group and waits for confirmation.
func (comp *Composer) Send(ctx context.Context) (*algokit.ComposerExecuteResult, error) {
	return comp.composer.Execute(ctx, 5)
}
