// Code generated by algokit-client-generator-go. DO NOT EDIT.
package revenuemanagerplugin

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/algorand/go-algorand-sdk/v2/types"
	algokit "github.com/kylebeee/algokit-utils-go"
)

// Client is a typed client for the RevenueManagerPlugin smart contract.
type Client struct {
	AppClient *algokit.AppClient
}

// NewClient creates a new typed client wrapping an existing AppClient.
func NewClient(appClient *algokit.AppClient) *Client {
	return &Client{AppClient: appClient}
}

// NewClientFromSpec creates a new typed client from AppClientParams.
func NewClientFromSpec(params algokit.AppClientParams) (*Client, error) {
	if params.AppSpec == nil {
		spec, err := GetAppSpec()
		if err != nil {
			return nil, err
		}
		params.AppSpec = spec
	}
	appClient, err := algokit.NewAppClient(params)
	if err != nil {
		return nil, err
	}
	return &Client{AppClient: appClient}, nil
}

// GetAppSpec returns the parsed ARC-56 app specification for this contract.
func GetAppSpec() (*algokit.Arc56Contract, error) {
	return algokit.ParseArc56Contract([]byte(AppSpecJSON))
}

// AppID returns the application ID.
func (c *Client) AppID() uint64 {
	return c.AppClient.AppID()
}

// AppAddress returns the application's escrow address.
func (c *Client) AppAddress() types.Address {
	return c.AppClient.AppAddress()
}

// NewGroup creates a new Composer for building atomic transaction groups.
func (c *Client) NewGroup() *Composer {
	return &Composer{
		client:   c,
		composer: c.AppClient.NewComposer(),
	}
}

// SendOptIn calls the optIn ABI method and waits for confirmation.
// optin exists because revenue manager uses additional metadata to track optin counts for processing payments
// revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
func (c *Client) SendOptIn(ctx context.Context, params algokit.CallParams[OptInArgs]) error {
	methodArgs := argsToInterfaceOptIn(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "optIn",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendNewReceiveEscrow calls the newReceiveEscrow ABI method and waits for confirmation.
// Creates a new receive escrow with direct splits
// Use this when you want to store splits directly in this contract
func (c *Client) SendNewReceiveEscrow(ctx context.Context, params algokit.CallParams[NewReceiveEscrowArgs]) error {
	methodArgs := argsToInterfaceNewReceiveEscrow(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "newReceiveEscrow",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendNewReceiveEscrowWithRef calls the newReceiveEscrowWithRef ABI method and waits for confirmation.
// Creates a new receive escrow with a reference to splits stored in another contract
// Use this when you want splits to be dynamically read from another contract's global state
func (c *Client) SendNewReceiveEscrowWithRef(ctx context.Context, params algokit.CallParams[NewReceiveEscrowWithRefArgs]) error {
	methodArgs := argsToInterfaceNewReceiveEscrowWithRef(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "newReceiveEscrowWithRef",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendStartEscrowDisbursement calls the startEscrowDisbursement ABI method and waits for confirmation.
func (c *Client) SendStartEscrowDisbursement(ctx context.Context, params algokit.CallParams[StartEscrowDisbursementArgs]) error {
	methodArgs := argsToInterfaceStartEscrowDisbursement(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "startEscrowDisbursement",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendProcessEscrowAllocation calls the processEscrowAllocation ABI method and waits for confirmation.
func (c *Client) SendProcessEscrowAllocation(ctx context.Context, params algokit.CallParams[ProcessEscrowAllocationArgs]) error {
	methodArgs := argsToInterfaceProcessEscrowAllocation(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "processEscrowAllocation",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendFinalizeEscrowDisbursement calls the finalizeEscrowDisbursement ABI method and waits for confirmation.
// Cleans up processed asset boxes and resets escrow back to idle state
// Must be called after all assets have been processed (escrow in Finalization phase)
// Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
func (c *Client) SendFinalizeEscrowDisbursement(ctx context.Context, params algokit.CallParams[FinalizeEscrowDisbursementArgs]) error {
	methodArgs := argsToInterfaceFinalizeEscrowDisbursement(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "finalizeEscrowDisbursement",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendUpdateAkitaDao calls the updateAkitaDAO ABI method and waits for confirmation.
func (c *Client) SendUpdateAkitaDao(ctx context.Context, params algokit.CallParams[UpdateAkitaDaoArgs]) error {
	methodArgs := argsToInterfaceUpdateAkitaDao(params.Args)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName:        "updateAkitaDAO",
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
		ExtraFee:          params.ExtraFee,
		StaticFee:         params.StaticFee,
		SendParams:        params.SendParams,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

// SendOpUp calls the opUp ABI method and waits for confirmation.
func (c *Client) SendOpUp(ctx context.Context) error {
	methodArgs := []interface{}(nil)

	result, err := c.AppClient.Send(ctx, algokit.AppCallSendParams{
		MethodName: "opUp",
		MethodArgs: methodArgs,
	})
	if err != nil {
		return err
	}

	_ = result
	return nil
}

func argsToInterfaceCreate(args CreateArgs) []interface{} {
	return []interface{}{
		args.Version,
		args.AkitaDao,
	}
}

func argsToInterfaceOptIn(args OptInArgs) []interface{} {
	return []interface{}{
		args.Wallet,
		args.RekeyBack,
		args.Assets,
		args.MBRPayment,
	}
}

func argsToInterfaceNewReceiveEscrow(args NewReceiveEscrowArgs) []interface{} {
	return []interface{}{
		args.Wallet,
		args.RekeyBack,
		args.Escrow,
		args.Source,
		args.Allocatable,
		args.OptinAllowed,
		args.Splits,
	}
}

func argsToInterfaceNewReceiveEscrowWithRef(args NewReceiveEscrowWithRefArgs) []interface{} {
	return []interface{}{
		args.Wallet,
		args.RekeyBack,
		args.Escrow,
		args.Source,
		args.Allocatable,
		args.OptinAllowed,
		args.SplitRef,
	}
}

func argsToInterfaceStartEscrowDisbursement(args StartEscrowDisbursementArgs) []interface{} {
	return []interface{}{
		args.Wallet,
		args.RekeyBack,
	}
}

func argsToInterfaceProcessEscrowAllocation(args ProcessEscrowAllocationArgs) []interface{} {
	return []interface{}{
		args.Wallet,
		args.RekeyBack,
		args.Ids,
	}
}

func argsToInterfaceFinalizeEscrowDisbursement(args FinalizeEscrowDisbursementArgs) []interface{} {
	return []interface{}{
		args.Wallet,
		args.RekeyBack,
		args.Ids,
	}
}

func argsToInterfaceUpdateAkitaDao(args UpdateAkitaDaoArgs) []interface{} {
	return []interface{}{
		args.AkitaDao,
	}
}

// Unmarshal helper for JSON decoding
func unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// Ensure fmt is used
var _ = fmt.Sprintf
