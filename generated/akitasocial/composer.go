// Code generated by algokit-client-generator-go. DO NOT EDIT.
package akitasocial

import (
	"context"

	algokit "github.com/kylebeee/algokit-utils-go"
)

// Composer builds atomic transaction groups for the AkitaSocial contract.
type Composer struct {
	client   *Client
	composer *algokit.TransactionComposer
}

// Init adds a init method call to the transaction group.
func (comp *Composer) Init(ctx context.Context) (*Composer, error) {
	methodArgs := []interface{}(nil)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "init" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:      comp.client.AppID(),
		Method:     method,
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// Post adds a post method call to the transaction group.
func (comp *Composer) Post(ctx context.Context, params algokit.CallParams[PostArgs]) (*Composer, error) {
	methodArgs := argsToInterfacePost(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "post" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// EditPost adds a editPost method call to the transaction group.
func (comp *Composer) EditPost(ctx context.Context, params algokit.CallParams[EditPostArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceEditPost(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "editPost" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GatedReply adds a gatedReply method call to the transaction group.
func (comp *Composer) GatedReply(ctx context.Context, params algokit.CallParams[GatedReplyArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGatedReply(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "gatedReply" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// Reply adds a reply method call to the transaction group.
func (comp *Composer) Reply(ctx context.Context, params algokit.CallParams[ReplyArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceReply(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "reply" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GatedEditReply adds a gatedEditReply method call to the transaction group.
func (comp *Composer) GatedEditReply(ctx context.Context, params algokit.CallParams[GatedEditReplyArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGatedEditReply(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "gatedEditReply" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// EditReply adds a editReply method call to the transaction group.
func (comp *Composer) EditReply(ctx context.Context, params algokit.CallParams[EditReplyArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceEditReply(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "editReply" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// Vote adds a vote method call to the transaction group.
func (comp *Composer) Vote(ctx context.Context, params algokit.CallParams[VoteArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceVote(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "vote" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// EditVote adds a editVote method call to the transaction group.
func (comp *Composer) EditVote(ctx context.Context, params algokit.CallParams[EditVoteArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceEditVote(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "editVote" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GatedReact adds a gatedReact method call to the transaction group.
func (comp *Composer) GatedReact(ctx context.Context, params algokit.CallParams[GatedReactArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGatedReact(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "gatedReact" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// React adds a react method call to the transaction group.
func (comp *Composer) React(ctx context.Context, params algokit.CallParams[ReactArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceReact(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "react" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// DeleteReaction adds a deleteReaction method call to the transaction group.
func (comp *Composer) DeleteReaction(ctx context.Context, params algokit.CallParams[DeleteReactionArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceDeleteReaction(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "deleteReaction" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// SetPostFlag adds a setPostFlag method call to the transaction group.
func (comp *Composer) SetPostFlag(ctx context.Context, params algokit.CallParams[SetPostFlagArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceSetPostFlag(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "setPostFlag" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// InitMeta adds a initMeta method call to the transaction group.
func (comp *Composer) InitMeta(ctx context.Context, params algokit.CallParams[InitMetaArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceInitMeta(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "initMeta" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// CreatePayWall adds a createPayWall method call to the transaction group.
func (comp *Composer) CreatePayWall(ctx context.Context, params algokit.CallParams[CreatePayWallArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceCreatePayWall(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "createPayWall" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// UpdateMeta adds a updateMeta method call to the transaction group.
func (comp *Composer) UpdateMeta(ctx context.Context, params algokit.CallParams[UpdateMetaArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceUpdateMeta(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "updateMeta" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// UpdateFollowerMeta adds a updateFollowerMeta method call to the transaction group.
func (comp *Composer) UpdateFollowerMeta(ctx context.Context, params algokit.CallParams[UpdateFollowerMetaArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceUpdateFollowerMeta(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "updateFollowerMeta" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// IsBanned adds a isBanned method call to the transaction group.
func (comp *Composer) IsBanned(ctx context.Context, params algokit.CallParams[IsBannedArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceIsBanned(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "isBanned" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetUserSocialImpact adds a getUserSocialImpact method call to the transaction group.
func (comp *Composer) GetUserSocialImpact(ctx context.Context, params algokit.CallParams[GetUserSocialImpactArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetUserSocialImpact(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getUserSocialImpact" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetMetaExists adds a getMetaExists method call to the transaction group.
func (comp *Composer) GetMetaExists(ctx context.Context, params algokit.CallParams[GetMetaExistsArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetMetaExists(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getMetaExists" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetMeta adds a getMeta method call to the transaction group.
func (comp *Composer) GetMeta(ctx context.Context, params algokit.CallParams[GetMetaArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetMeta(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getMeta" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetPostExists adds a getPostExists method call to the transaction group.
func (comp *Composer) GetPostExists(ctx context.Context, params algokit.CallParams[GetPostExistsArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetPostExists(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getPostExists" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetPost adds a getPost method call to the transaction group.
func (comp *Composer) GetPost(ctx context.Context, params algokit.CallParams[GetPostArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetPost(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getPost" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetVote adds a getVote method call to the transaction group.
func (comp *Composer) GetVote(ctx context.Context, params algokit.CallParams[GetVoteArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetVote(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getVote" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetVotes adds a getVotes method call to the transaction group.
func (comp *Composer) GetVotes(ctx context.Context, params algokit.CallParams[GetVotesArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetVotes(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getVotes" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// GetReactionExists adds a getReactionExists method call to the transaction group.
func (comp *Composer) GetReactionExists(ctx context.Context, params algokit.CallParams[GetReactionExistsArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceGetReactionExists(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "getReactionExists" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// MBR adds a mbr method call to the transaction group.
func (comp *Composer) MBR(ctx context.Context, params algokit.CallParams[MBRArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceMBR(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "mbr" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// PayWallMBR adds a payWallMbr method call to the transaction group.
func (comp *Composer) PayWallMBR(ctx context.Context, params algokit.CallParams[PayWallMBRArgs]) (*Composer, error) {
	methodArgs := argsToInterfacePayWallMBR(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "payWallMbr" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// CheckTipMBRRequirements adds a checkTipMbrRequirements method call to the transaction group.
func (comp *Composer) CheckTipMBRRequirements(ctx context.Context, params algokit.CallParams[CheckTipMBRRequirementsArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceCheckTipMBRRequirements(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "checkTipMbrRequirements" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// UpdateAkitaDaoEscrow adds a updateAkitaDAOEscrow method call to the transaction group.
func (comp *Composer) UpdateAkitaDaoEscrow(ctx context.Context, params algokit.CallParams[UpdateAkitaDaoEscrowArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceUpdateAkitaDaoEscrow(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "updateAkitaDAOEscrow" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// UpdateAkitaDao adds a updateAkitaDAO method call to the transaction group.
func (comp *Composer) UpdateAkitaDao(ctx context.Context, params algokit.CallParams[UpdateAkitaDaoArgs]) (*Composer, error) {
	methodArgs := argsToInterfaceUpdateAkitaDao(params.Args)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "updateAkitaDAO" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:             comp.client.AppID(),
		Method:            method,
		MethodArgs:        methodArgs,
		Sender:            params.Sender,
		Signer:            params.Signer,
		Note:              params.Note,
		BoxReferences:     params.BoxReferences,
		AccountReferences: params.AccountReferences,
		AppReferences:     params.AppReferences,
		AssetReferences:   params.AssetReferences,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// OpUp adds a opUp method call to the transaction group.
func (comp *Composer) OpUp(ctx context.Context) (*Composer, error) {
	methodArgs := []interface{}(nil)

	method, err := comp.client.AppClient.AppSpec().Methods[0].ToABIMethod()
	for _, m := range comp.client.AppClient.AppSpec().Methods {
		if m.Name == "opUp" {
			method, err = m.ToABIMethod()
			break
		}
	}
	if err != nil {
		return nil, err
	}

	err = comp.composer.AddMethodCall(ctx, algokit.MethodCallParams{
		AppID:      comp.client.AppID(),
		Method:     method,
		MethodArgs: methodArgs,
	})
	if err != nil {
		return nil, err
	}
	return comp, nil
}

// Send executes the composed transaction group and waits for confirmation.
func (comp *Composer) Send(ctx context.Context) (*algokit.ComposerExecuteResult, error) {
	return comp.composer.Execute(ctx, 5)
}
